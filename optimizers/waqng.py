import pennylane as qmlfrom pennylane import numpy as npfrom typing import Callable, List, Optional, Tuple, Unionclass WAQNGOptimizer:    """    Weighted Approximate Quantum Natural Gradient (WA-QNG) optimizer    with optional trust-region-style adaptive damping.    Update:        θ' = θ - η (W + λ I)^{-1} ∇L(θ)    If lu=True:        - If energy decreases: accept step, λ ↓        - If energy increases: reject step (keep θ), λ ↑    """    def __init__(        self,        qnode: Callable,        hamiltonian_terms: Union[qml.Hamiltonian, List[Tuple[float, qml.operation.Operator]]],        eta: float = 0.1,        lam: float = 1e-6,        lu: bool = False,        rcond: float = 1e-10,        normalize_weights: bool = True,        c_prefactor: Optional[float] = 2.0,        diff_method: str = "parameter-shift",        device: Optional[qml.devices.Device] = None,    ):        self.qnode = qnode        self.device = device        self.eta = eta         self.lam = lam        self.lu = lu        self.lam_factor = 10.0        self.rcond = rcond        self.normalize_weights = normalize_weights        self.c_prefactor = 2.0 if c_prefactor is None else c_prefactor        self.diff_method = diff_method        if isinstance(hamiltonian_terms, qml.Hamiltonian):            coeffs = hamiltonian_terms.coeffs            ops = hamiltonian_terms.ops            self.terms = list(zip(coeffs, ops))        else:            self.terms = list(hamiltonian_terms)        self._wire_groups: List[Tuple[Tuple[int, ...], List[int]]] = []        wire_to_gid = {}        self._term_group: List[int] = []        for idx, (_, op) in enumerate(self.terms):            wires = tuple(int(w) for w in op.wires.tolist())            if wires not in wire_to_gid:                wire_to_gid[wires] = len(self._wire_groups)                self._wire_groups.append((wires, [idx]))            else:                gid = wire_to_gid[wires]                self._wire_groups[gid][1].append(idx)            self._term_group.append(wire_to_gid[wires])    def step(self, cost_fn, theta, *args, **kwargs):        theta = np.asarray(theta, dtype=float)        old_cost = float(cost_fn(theta, *args, **kwargs))        g = self._gradient(cost_fn, theta, *args, **kwargs)        F = self._weighted_hs_metric(theta)        d = F.shape[0]        lam = self.lam        F_reg = F + lam * np.eye(d)        F_pinv = np.linalg.pinv(F_reg, rcond=self.rcond)        delta = self.eta * F_pinv @ g        new_theta = theta - delta        new_cost = float(cost_fn(new_theta, *args, **kwargs))        if self.lu:            if new_cost < old_cost:                self.lam = max(lam / self.lam_factor, 1e-8)                return new_theta            else:                print(f"[WAQNG] Rejecting step: E_new={new_cost:.6f} >= E_old={old_cost:.6f}. λ → {lam*self.lam_factor:.1e}")                self.lam = lam * self.lam_factor                return theta          else:            return new_theta    def _gradient(self, cost_fn, theta, *args, **kwargs):        grad_fn = qml.grad(cost_fn)        return np.asarray(grad_fn(theta, *args, **kwargs), dtype=float)    def _weighted_hs_metric(self, theta: np.ndarray) -> np.ndarray:        n_params = theta.size        group_metrics = [np.zeros((n_params, n_params), dtype=float) for _ in self._wire_groups]        coeffs = np.array([float(c) for c, _ in self.terms], dtype=float)        w_i = coeffs ** 2        w_sum = float(np.sum(w_i)) if self.normalize_weights else 1.0        if w_sum == 0.0:            w_sum = 1.0        for gid, (wires, term_indices) in enumerate(self._wire_groups):            dm_qnode = self._make_dm_qnode(wires)            def dm_flat(theta_):                rho = dm_qnode(theta_)                rho_real = qml.math.real(rho)                return qml.math.flatten(rho_real)            J = qml.jacobian(dm_flat, argnum=0)(theta)            G = 0.5 * (J.T @ J)            weight_group = float(np.sum(w_i[term_indices]))            group_metrics[gid] = weight_group * G        F = np.zeros((n_params, n_params), dtype=float)        for Gw in group_metrics:            F += Gw        if self.normalize_weights:            F *= (self.c_prefactor / w_sum)        else:            F *= self.c_prefactor        return F    def _make_dm_qnode(self, wires: Tuple[int, ...]) -> qml.QNode:        dev = self.device        if dev is None:            maxwire = max(wires)            dev = qml.device("default.qubit", wires=list(range(maxwire + 1)))        func = self.qnode        @qml.qnode(dev, interface="autograd", diff_method="backprop")        def dm_circuit(theta_):            func(theta_)            return qml.density_matrix(wires)        return dm_circuitif __name__ == "__main__":    n_qubits = 4    dev = qml.device("default.qubit", wires=n_qubits)    def ansatz(theta):        idx = 0        for l in range(2):            for w in range(n_qubits):                qml.RY(theta[idx], wires=w)                idx += 1            for w in range(n_qubits - 1):                qml.CNOT(wires=[w, w + 1])    terms = []    J = 1.0    h = 0.5    for w in range(n_qubits - 1):        terms.append((-J, qml.PauliZ(w) @ qml.PauliZ(w + 1)))    for w in range(n_qubits):        terms.append((-h, qml.PauliX(w)))    H = qml.Hamiltonian([c for c, _ in terms], [op for _, op in terms])    @qml.qnode(dev, interface="autograd")    def energy(theta):        ansatz(theta)        return qml.expval(H)    opt = WAQNGOptimizer(        qnode=ansatz,        hamiltonian_terms=H,        eta=1e-3,        lam=1e-5,        lu=True,                device=dev    )    theta = 0.1 * np.random.randn(2 * n_qubits)    print(f"Optimizer using device wires: {opt.device.wires}")    for t in range(10):        theta = opt.step(energy, theta)        print(f"iter {t+1:3d} | E = {energy(theta): .6f} | λ = {opt.lam:.2e}")